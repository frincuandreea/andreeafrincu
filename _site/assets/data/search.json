[
  
  {
    "title"    : "Using HTL in AEM application",
    "category" : "",
    "tags"     : " HTL, AEM",
    "url"      : "/aem/2020/11/04/Sightly-HTL-aem-usage.html",
    "date"     : "November 4, 2020",
    "excerpt"  : "Today I am going to write about HTL. HTL comes from HTML Template Language and is the recommended server-side template system for the HTML in AEM. This was introduced to take place of the JSP (JavaServer Pages) which was used in the previous versi...",
  "content"  : "Today I am going to write about HTL. HTL comes from HTML Template Language and is the recommended server-side template system for the HTML in AEM. This was introduced to take place of the JSP (JavaServer Pages) which was used in the previous versions of AEM.\n\nI always notice that when somebody comes new into an AEM project and I am talking about HTL they do not have a clue what I am talking about. My advice if you want to start working with an AEM application please read the AEM documentation about HTL. I will write in this post what are the important points which you need to know in order to write server-side HTML.\n\nBefore starting creating any component in AEM we need to know about the following topics in HTL:\n\n\n  Global Objects\n  Block Statements\n  Expression Language\n\n\nGlobal Objects\n\nIn the first moment after you create the corresponding html file of your AEM component you need to know that you can access some objects which are called Global Objects.\nThe most used global objects are:\n\n\n  \n    \n      Object name\n      Description\n    \n  \n  \n    \n      properties\n      contains the list of properties of the current resource, for example your component; type org.apache.sling.api.resource.ValueMap\n    \n    \n      pageProperties\n      a list of page properties which contains your component; type org.apache.sling.api.resource.ValueMap\n    \n    \n      inheritedPageProperties\n      list of inherited page properties of the current page; type org.apache.sling.api.resource.ValueMap\n    \n    \n      currentPage\n      allow access to the current page where the component is included; type com.day.cq.wcm.api.Page\n    \n    \n      resource\n      allow access to the current resource in this case is the component resource; type org.apache.sling.api.resource.Resource\n    \n    \n      request\n      allow access to the current request; type org.apache.sling.api.SlingHttpServletRequest\n    \n    \n      response\n      allow access to the current response where you can add headers, cookies; type org.apache.sling.api.SlingHttpServletResponse\n    \n  \n\n\nYou can find more global objects on the adobe documentation about this at AEM Global Objects.\n\nBlock Statements\n\nThe most used statements are:\n\n1. data-sly-use - initializes a helper object and expose it through a variable. Below you can see example of usages.\n\n\n  initialize a javascript object which is in the same directory with the template file\n\n\n&amp;lt;div data-sly-use.head=&quot;head.js&quot;&amp;gt;${head.title}&amp;lt;/div&amp;gt;\n&amp;lt;div data-sly-use.head=&quot;${&#39;head.js&#39; @param=&#39;test&#39;}&quot;&amp;gt;${head.title}&amp;lt;/div&amp;gt;\n\n\n\n  initialize a Java object which is in the same directory with the template file\n\n\n&amp;lt;div data-sly-use.head=&quot;Head&quot;&amp;gt;${head.title}&amp;lt;/div&amp;gt;\n\n\n\n  initialize a Java object which is in not in the same directory with the template file\n\n\n&amp;lt;div data-sly-use.head=&quot;org.example.mypackage.Head&quot;&amp;gt;${head.title}&amp;lt;/div&amp;gt;\n\n\n\n  initialize another HTL template\n\n\n&amp;lt;div data-sly-use.header=&quot;headerTemplate.html&quot; data-sly-call=&quot;${header.simple}&quot;&amp;gt;&amp;lt;/div&amp;gt;\n\n\n2. data-sly-unwrap - removes the host element.\n\n&amp;lt;p data-sly-unwrap&amp;gt;Hello there!&amp;lt;/p&amp;gt;\n\n\nThe result of the expression above is : Hello there! without any html tag.\n\n3. data-sly-attribute - add attributes to the host element.\n\n&amp;lt;p data-sly-attribute.id=&quot;test&quot;&amp;gt;Hello there!&amp;lt;/p&amp;gt;\n\n\nThe result of the expression above is:\n\n&amp;lt;p id=&quot;test&quot;&amp;gt;Hello there!&amp;lt;/p&amp;gt;\n\n\n4. data-sly-test - conditional expression if the condition is true then the host element is displayed otherwise is removed.\n\n&amp;lt;div data-sly-test.cond=&quot;${flag1 &amp;amp;&amp;amp; flag2}&quot;&amp;gt;When flag1 and flag2 are true I am displayed!&amp;lt;/div&amp;gt;\n\n\n5. data-sly-list - repeats the host element for every element from the enumerable.\n\n&amp;lt;ul&amp;gt;\n&amp;lt;li data-sly-list.child=&quot;${resource.listChildren}&quot;&amp;gt;\n    &amp;lt;span&amp;gt;index: ${childList.index}&amp;lt;/span&amp;gt;\n    &amp;lt;span&amp;gt;value: ${child.title}&amp;lt;/span&amp;gt;\n&amp;lt;/li&amp;gt;\n&amp;lt;/ul&amp;gt;\n\n\nInside the list using the childList you also have access to the following properties:\n\n\n  count - one based counter (1…length)\n  first - true if the current element is the first one\n  middle - true if the current element is not the first or the last\n  last - true if the current element is the last\n  odd - true if the index is odd\n  even - true if the index is even\n\n\n6. data-sly-resource - includes the result of rendering the indicating resource.\n\n&amp;lt;div data-sly-resource=&quot;path/to/resource&quot;&amp;gt;&amp;lt;/div&amp;gt;\n&amp;lt;div data-sly-resource=&quot;${resource.path}&quot;&amp;gt;&amp;lt;/div&amp;gt;\n&amp;lt;div data-sly-resource=&quot;${&#39;test&#39; @ resourceType=&#39;my/resource/type&#39;}&quot;&amp;gt;&amp;lt;/div&amp;gt;\n\n\n7. data-sly-include - replaces the content of the host element with the markup generated by the HTL file which is included.\n\n&amp;lt;div data-sly-include=&quot;path/to/template.html&quot;&amp;gt;&amp;lt;/div&amp;gt;\n\n\n8. data-sly-template - defines a template.\n\n&amp;lt;template data-sly-template.test=&quot;${ @ text}&quot;&amp;gt;&amp;lt;h2&amp;gt;${text}&amp;lt;/h2&amp;gt;&amp;lt;/div&amp;gt;\n\n\n9. data-sly-call - calls a template defined by the data-sly-template.\n\n&amp;lt;template data-sly-template.test=&quot;${ @ text}&quot;&amp;gt;&amp;lt;h2&amp;gt;${text}&amp;lt;/h2&amp;gt;&amp;lt;/div&amp;gt;\n&amp;lt;div data-sly-call=&quot;${test @ text=&#39;testText&#39;}&quot;&amp;gt;&amp;lt;/div&amp;gt;\n\n\nExpression Language\n\nThe HTL uses an expression language to access the data structure. This expressions are delimited by ${ and }.\nThe expression syntax contains variables, operators, literals and options. In the AEM documentation you can fin much more about this just folow the link AEM Expression Language.\n\nThis is the summary about the HTL if you follow the links that I provide it you will find much more. Thank you  for reading this if you like it please feel free to share it. If you have any suggestion I am open to it.\n"
} ,
  
  {
    "title"    : "Convert @SlingServlet to @Component",
    "category" : "",
    "tags"     : " AEM6.4, OSGI, SlingServlet, Component, Migration",
    "url"      : "/aem/2019/09/22/Convert-SlingServlet-example.html",
    "date"     : "September 22, 2019",
    "excerpt"  : "Last problem that I had to work was actually to convert all the apache felix annotation to the new R6 OSGI annotation. Anybody who is working in an AEM project knows that once you update your project to run with the AEM 6.4 server you have to upda...",
  "content"  : "Last problem that I had to work was actually to convert all the apache felix annotation to the new R6 OSGI annotation. Anybody who is working in an AEM project knows that once you update your project to run with the AEM 6.4 server you have to update the annotation of all your services, servlets, components to the R6 OSGI.\n\nIn this post I will explain how this can be done for the servlets with examples.\n\nCode highlighting examples\n\nA simple servlet which is using the @SlingServlet looks like this:\n\nJava\n\njava example\n\n@SlingServlet(\n    paths = {&quot;/pathtest/content&quot;},\n    methods = {&quot;GET&quot;, &quot;PUT&quot;},\n    name = &quot;com.servlet.TestServlet&quot;\n)\n@Properties({\n       @Property(name = Constants.SERVICE_VENDOR, value = &quot;Test Vendor&quot;),\n       @Property(name = Constants.SERVICE_DESCRIPTION, value = &quot;Test description&quot;),\n})\n\npublic class TestServlet extends SlingAllMethodsServlet {\n\n    @Override\n        protected void doGet(SlingHttpServletRequest request, @NotNull SlingHttpServletResponse response) throws IOException {\n          responseHTML = &quot;&amp;lt;div&amp;gt;This is a test Servlet&amp;lt;/div&amp;gt;&quot;\n          response.setContentType(&quot;text/html&quot;);\n          response.setCharacterEncoding(&quot;UTF-8&quot;);\n          response.setStatus(200);\n          response.getWriter().write(responseHTML);\n        }\n}\n\nIf we are converting the servlet above the we get the following result:\n\n\n@Component(\n    immediate = true,\n    service ={Servlet.class},\n    property = {\n        &quot;sling.servlet.paths=/pathtest/content&quot;,\n        &quot;sling.servlet.methods=get&quot;,\n        &quot;sling.servlet.methods=put&quot;,\n        &quot;sling.core.servletName=com.servlet.TestServlet&quot;,\n        Constants.SERVICE_VENDOR+&quot;=Test Vendor&quot;,\n        Constants.SERVICE_DESCRIPTION+&quot;=Test description&quot;\n    }\n)\n\npublic class TestServlet extends SlingAllMethodsServlet {\n\n @Override\n        protected void doGet(SlingHttpServletRequest request, @NotNull SlingHttpServletResponse response) throws IOException {\n          responseHTML = &quot;&amp;lt;div&amp;gt;This is a test Servlet&amp;lt;/div&amp;gt;&quot;\n          response.setContentType(&quot;text/html&quot;);\n          response.setCharacterEncoding(&quot;UTF-8&quot;);\n          response.setStatus(200);\n          response.getWriter().write(responseHTML);\n        }\n}\n\nComparing the two portions of code we see immediate that before we were using the @SlingServlet annotation but now we use the @Component annotation and we referrer to servlet using the attribute “service ={Servlet.class}”. A second part that change is the property paths and methods are now replace as following:\n\n\n  paths = {“/pathtest/content”} is replaced by “sling.servlet.paths=/pathtest/content”\n  methods = {“GET”, “PUT”} are replaced by the properties “sling.servlet.methods=get” and “sling.servlet.methods=put”\n  name = “com.servlet.TestServlet” is replaced by the “sling.core.servletName=com.servlet.TestServlet”\n\n\nPretty much this is it. It is not too complicated. What is really helpful is the Sling Apache documentation about servlets you can find it  here .\n"
} 
  
  
  
]
